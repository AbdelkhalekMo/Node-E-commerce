import { Directive, Injectable, Input, NgModule } from '@angular/core';
// Duplicated import to work around a TypeScript bug where it'd complain that `Router` isn't imported as a type.
// We need to import it as a value to satisfy Angular dependency injection. So:
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { NavigationCancel, NavigationError } from '@angular/router';
import { NavigationEnd, NavigationStart, ResolveEnd } from '@angular/router';
import { WINDOW, browserTracingIntegration as originalBrowserTracingIntegration, getCurrentScope, startBrowserTracingNavigationSpan, } from '@sentry/browser';
import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, getActiveSpan, getClient, spanToJSON, startInactiveSpan, } from '@sentry/core';
import { logger, stripUrlQueryAndFragment, timestampInSeconds } from '@sentry/utils';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
let stashedStartTransaction;
let stashedStartTransactionOnLocationChange;
let hooksBasedInstrumentation = false;
/**
 * Creates routing instrumentation for Angular Router.
 *
 * @deprecated Use `browserTracingIntegration()` instead, which includes Angular-specific instrumentation out of the box.
 */
export function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
    instrumentationInitialized = true;
    stashedStartTransaction = customStartTransaction;
    stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {
        customStartTransaction({
            name: WINDOW.location.pathname,
            op: 'pageload',
            origin: 'auto.pageload.angular',
            attributes: {
                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
            },
        });
    }
}
/**
 * Creates routing instrumentation for Angular Router.
 *
 * @deprecated Use `browserTracingIntegration()` instead, which includes Angular-specific instrumentation out of the box.
 */
// eslint-disable-next-line deprecation/deprecation
export const instrumentAngularRouting = routingInstrumentation;
/**
 * A custom BrowserTracing integration for Angular.
 *
 * Use this integration in combination with `TraceService`
 */
export function browserTracingIntegration(options = {}) {
    // If the user opts out to set this up, we just don't initialize this.
    // That way, the TraceService will not actually do anything, functionally disabling this.
    if (options.instrumentNavigation !== false) {
        instrumentationInitialized = true;
        hooksBasedInstrumentation = true;
    }
    return originalBrowserTracingIntegration(Object.assign(Object.assign({}, options), { instrumentNavigation: false }));
}
/**
 * Grabs active transaction off scope.
 *
 * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
 */
export function getActiveTransaction() {
    // eslint-disable-next-line deprecation/deprecation
    return getCurrentScope().getTransaction();
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            if (this._routingSpan) {
                this._routingSpan.end();
                this._routingSpan = null;
            }
            const client = getClient();
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            if (client && hooksBasedInstrumentation) {
                if (!getActiveSpan()) {
                    startBrowserTracingNavigationSpan(client, {
                        name: strippedUrl,
                        origin: 'auto.navigation.angular',
                        attributes: {
                            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                        },
                    });
                }
                // eslint-disable-next-line deprecation/deprecation
                this._routingSpan =
                    startInactiveSpan({
                        name: `${navigationEvent.url}`,
                        op: ANGULAR_ROUTING_OP,
                        origin: 'auto.ui.angular',
                        tags: Object.assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                            navigationTrigger: navigationEvent.navigationTrigger,
                        })),
                    }) || null;
                return;
            }
            // eslint-disable-next-line deprecation/deprecation
            let activeTransaction = getActiveTransaction();
            if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                activeTransaction = stashedStartTransaction({
                    name: strippedUrl,
                    op: 'navigation',
                    origin: 'auto.navigation.angular',
                    attributes: {
                        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                    },
                });
            }
            if (activeTransaction) {
                // eslint-disable-next-line deprecation/deprecation
                this._routingSpan = activeTransaction.startChild({
                    description: `${navigationEvent.url}`,
                    op: ANGULAR_ROUTING_OP,
                    origin: 'auto.ui.angular',
                    tags: Object.assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                        navigationTrigger: navigationEvent.navigationTrigger,
                    })),
                });
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            // eslint-disable-next-line deprecation/deprecation
            const transaction = getActiveTransaction();
            // TODO (v8 / #5416): revisit the source condition. Do we want to make the parameterized route the default?
            const attributes = (transaction && spanToJSON(transaction).data) || {};
            if (transaction && attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'url') {
                transaction.updateName(route);
                transaction.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');
                transaction.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, `auto.${spanToJSON(transaction).op}.angular`);
            }
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd || event instanceof NavigationCancel || event instanceof NavigationError), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.end();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
TraceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceService, deps: [{ token: i1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
TraceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.Router }]; } });
const UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export class TraceDirective {
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        if (!this.componentName) {
            this.componentName = UNKNOWN_COMPONENT;
        }
        // eslint-disable-next-line deprecation/deprecation
        const activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            // eslint-disable-next-line deprecation/deprecation
            this._tracingSpan = activeTransaction.startChild({
                description: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
                origin: 'auto.ui.angular.trace_directive',
            });
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        if (this._tracingSpan) {
            this._tracingSpan.end();
        }
    }
}
TraceDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
TraceDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TraceDirective, selector: "[trace]", inputs: { componentName: ["trace", "componentName"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[trace]' }]
        }], propDecorators: { componentName: [{
                type: Input,
                args: ['trace']
            }] } });
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TraceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceModule, declarations: [TraceDirective], exports: [TraceDirective] });
TraceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TraceModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TraceDirective],
                    exports: [TraceDirective],
                }]
        }] });
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClassDecorator() {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function (...args) {
            // eslint-disable-next-line deprecation/deprecation
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                // eslint-disable-next-line deprecation/deprecation
                tracingSpan = activeTransaction.startChild({
                    description: `<${target.name}>`,
                    op: ANGULAR_INIT_OP,
                    origin: 'auto.ui.angular.trace_class_decorator',
                });
            }
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                tracingSpan.end();
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethodDecorator() {
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function (...args) {
            const now = timestampInSeconds();
            // eslint-disable-next-line deprecation/deprecation
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                // eslint-disable-next-line deprecation/deprecation
                activeTransaction.startChild({
                    description: `<${target.constructor.name}>`,
                    endTimestamp: now,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    origin: 'auto.ui.angular.trace_method_decorator',
                    startTimestamp: now,
                });
            }
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concatenated
 *
 * @returns the concatenated parameterized route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const parts = [];
    let currentRoute = route && route.firstChild;
    while (currentRoute) {
        const path = currentRoute && currentRoute.routeConfig && currentRoute.routeConfig.path;
        if (path === null || path === undefined) {
            break;
        }
        parts.push(path);
        currentRoute = currentRoute.firstChild;
    }
    const fullPath = parts.filter(part => part).join('/');
    return fullPath ? `/${fullPath}/` : '/';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFjaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdkUsZ0hBQWdIO0FBQ2hILCtFQUErRTtBQUMvRSxzRUFBc0U7QUFDdEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBVSxNQUFNLGlCQUFpQixDQUFDO0FBQzVFLE9BQU8sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdFLE9BQU8sRUFDTCxNQUFNLEVBQ04seUJBQXlCLElBQUksaUNBQWlDLEVBQzlELGVBQWUsRUFDZixpQ0FBaUMsR0FDbEMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQ0wsZ0NBQWdDLEVBQ2hDLGdDQUFnQyxFQUNoQyxhQUFhLEVBQ2IsU0FBUyxFQUNULFVBQVUsRUFDVixpQkFBaUIsR0FDbEIsTUFBTSxjQUFjLENBQUM7QUFFdEIsT0FBTyxFQUFFLE1BQU0sRUFBRSx3QkFBd0IsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxRQUFRLENBQUM7OztBQUUzQyxJQUFJLDBCQUFtQyxDQUFDO0FBQ3hDLElBQUksdUJBQWlGLENBQUM7QUFDdEYsSUFBSSx1Q0FBZ0QsQ0FB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YWJsZSBtYXgtbGluZXMgKi9cbmltcG9ydCB0eXBlIHsgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5qZWN0YWJsZSwgSW5wdXQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgdHlwZSB7IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIEV2ZW50LCBSb3V0ZXJTdGF0ZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG4vLyBEdXBsaWNhdGVkIGltcG9ydCB0byB3b3JrIGFyb3VuZCBhIFR5cGVTY3JpcHQgYnVnIHdoZXJlIGl0J2QgY29tcGxhaW4gdGhhdCBgUm91dGVyYCBpc24ndCBpbXBvcnRlZCBhcyBhIHR5cGUuXG4vLyBXZSBuZWVkIHRvIGltcG9ydCBpdCBhcyBhIHZhbHVlIHRvIHNhdGlzZnkgQW5ndWxhciBkZXBlbmRlbmN5IGluamVjdGlvbi4gU286XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1pbXBvcnRzXG5pbXBvcnQgeyBOYXZpZ2F0aW9uQ2FuY2VsLCBOYXZpZ2F0aW9uRXJyb3IsIFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uU3RhcnQsIFJlc29sdmVFbmQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHtcbiAgV0lORE9XLFxuICBicm93c2VyVHJhY2luZ0ludGVncmF0aW9uIGFzIG9yaWdpbmFsQnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbixcbiAgZ2V0Q3VycmVudFNjb3BlLFxuICBzdGFydEJyb3dzZXJUcmFjaW5nTmF2aWdhdGlvblNwYW4sXG59IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG5pbXBvcnQge1xuICBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTixcbiAgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UsXG4gIGdldEFjdGl2ZVNwYW4sXG4gIGdldENsaWVudCxcbiAgc3BhblRvSlNPTixcbiAgc3RhcnRJbmFjdGl2ZVNwYW4sXG59IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgdHlwZSB7IEludGVncmF0aW9uLCBTcGFuLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25Db250ZXh0IH0gZnJvbSAnQHNlbnRyeS90eXBlcyc7XG5pbXBvcnQgeyBsb2dnZXIsIHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudCwgdGltZXN0YW1wSW5TZWNvbmRzIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5pbXBvcnQgdHlwZSB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEFOR1VMQVJfSU5JVF9PUCwgQU5HVUxBUl9PUCwgQU5HVUxBUl9ST1VUSU5HX09QIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgSVNfREVCVUdfQlVJTEQgfSBmcm9tICcuL2ZsYWdzJztcbmltcG9ydCB7IHJ1bk91dHNpZGVBbmd1bGFyIH0gZnJvbSAnLi96b25lJztcblxubGV0IGluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkOiBib29sZWFuO1xubGV0IHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uOiAoY29udGV4dDogVHJhbnNhY3Rpb25Db250ZXh0KSA9PiBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZDtcbmxldCBzdGFzaGVkU3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2U6IGJvb2xlYW47XG5cbmxldCBob29rc0Jhc2VkSW5zdHJ1bWVudGF0aW9uID0gZmFsc2U7XG5cbi8qKlxuICogQ3JlYXRlcyByb3V0aW5nIGluc3RydW1lbnRhdGlvbiBmb3IgQW5ndWxhciBSb3V0ZXIuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBicm93c2VyVHJhY2luZ0ludGVncmF0aW9uKClgIGluc3RlYWQsIHdoaWNoIGluY2x1ZGVzIEFuZ3VsYXItc3BlY2lmaWMgaW5zdHJ1bWVudGF0aW9uIG91dCBvZiB0aGUgYm94LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91dGluZ0luc3RydW1lbnRhdGlvbihcbiAgY3VzdG9tU3RhcnRUcmFuc2FjdGlvbjogKGNvbnRleHQ6IFRyYW5zYWN0aW9uQ29udGV4dCkgPT4gVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQsXG4gIHN0YXJ0VHJhbnNhY3Rpb25PblBhZ2VMb2FkOiBib29sZWFuID0gdHJ1ZSxcbiAgc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2U6IGJvb2xlYW4gPSB0cnVlLFxuKTogdm9pZCB7XG4gIGluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb24gPSBjdXN0b21TdGFydFRyYW5zYWN0aW9uO1xuICBzdGFzaGVkU3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2UgPSBzdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZTtcblxuICBpZiAoc3RhcnRUcmFuc2FjdGlvbk9uUGFnZUxvYWQgJiYgV0lORE9XICYmIFdJTkRPVy5sb2NhdGlvbikge1xuICAgIGN1c3RvbVN0YXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgbmFtZTogV0lORE9XLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgb3A6ICdwYWdlbG9hZCcsXG4gICAgICBvcmlnaW46ICdhdXRvLnBhZ2Vsb2FkLmFuZ3VsYXInLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAndXJsJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIHJvdXRpbmcgaW5zdHJ1bWVudGF0aW9uIGZvciBBbmd1bGFyIFJvdXRlci5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24oKWAgaW5zdGVhZCwgd2hpY2ggaW5jbHVkZXMgQW5ndWxhci1zcGVjaWZpYyBpbnN0cnVtZW50YXRpb24gb3V0IG9mIHRoZSBib3guXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuZXhwb3J0IGNvbnN0IGluc3RydW1lbnRBbmd1bGFyUm91dGluZyA9IHJvdXRpbmdJbnN0cnVtZW50YXRpb247XG5cbi8qKlxuICogQSBjdXN0b20gQnJvd3NlclRyYWNpbmcgaW50ZWdyYXRpb24gZm9yIEFuZ3VsYXIuXG4gKlxuICogVXNlIHRoaXMgaW50ZWdyYXRpb24gaW4gY29tYmluYXRpb24gd2l0aCBgVHJhY2VTZXJ2aWNlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbihcbiAgb3B0aW9uczogUGFyYW1ldGVyczx0eXBlb2Ygb3JpZ2luYWxCcm93c2VyVHJhY2luZ0ludGVncmF0aW9uPlswXSA9IHt9LFxuKTogSW50ZWdyYXRpb24ge1xuICAvLyBJZiB0aGUgdXNlciBvcHRzIG91dCB0byBzZXQgdGhpcyB1cCwgd2UganVzdCBkb24ndCBpbml0aWFsaXplIHRoaXMuXG4gIC8vIFRoYXQgd2F5LCB0aGUgVHJhY2VTZXJ2aWNlIHdpbGwgbm90IGFjdHVhbGx5IGRvIGFueXRoaW5nLCBmdW5jdGlvbmFsbHkgZGlzYWJsaW5nIHRoaXMuXG4gIGlmIChvcHRpb25zLmluc3RydW1lbnROYXZpZ2F0aW9uICE9PSBmYWxzZSkge1xuICAgIGluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBob29rc0Jhc2VkSW5zdHJ1bWVudGF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbEJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24oe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgaW5zdHJ1bWVudE5hdmlnYXRpb246IGZhbHNlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBHcmFicyBhY3RpdmUgdHJhbnNhY3Rpb24gb2ZmIHNjb3BlLlxuICpcbiAqIEBkZXByZWNhdGVkIFlvdSBzaG91bGQgbm90IHJlbHkgb24gdGhlIHRyYW5zYWN0aW9uLCBidXQganVzdCB1c2UgYHN0YXJ0U3BhbigpYCBBUElzIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmVUcmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICByZXR1cm4gZ2V0Q3VycmVudFNjb3BlKCkuZ2V0VHJhbnNhY3Rpb24oKTtcbn1cblxuLyoqXG4gKiBBbmd1bGFyJ3MgU2VydmljZSByZXNwb25zaWJsZSBmb3IgaG9va2luZyBpbnRvIEFuZ3VsYXIgUm91dGVyIGFuZCB0cmFja2luZyBjdXJyZW50IG5hdmlnYXRpb24gcHJvY2Vzcy5cbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24gZm9yIGV2ZXJ5IHJvdXRlIGNoYW5nZSBhbmQgbWVhc3VyZXMgYSBkdXJhdGlvbiBvZiByb3V0aW5nIHByb2Nlc3MuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHVibGljIG5hdlN0YXJ0JDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIE5hdmlnYXRpb25TdGFydCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCksXG4gICAgdGFwKG5hdmlnYXRpb25FdmVudCA9PiB7XG4gICAgICBpZiAoIWluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkKSB7XG4gICAgICAgIElTX0RFQlVHX0JVSUxEICYmXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdBbmd1bGFyIGludGVncmF0aW9uIGhhcyB0cmFjaW5nIGVuYWJsZWQsIGJ1dCBUcmFjaW5nIGludGVncmF0aW9uIGlzIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JvdXRpbmdTcGFuKSB7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuLmVuZCgpO1xuICAgICAgICB0aGlzLl9yb3V0aW5nU3BhbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICAgICAgY29uc3Qgc3RyaXBwZWRVcmwgPSBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQobmF2aWdhdGlvbkV2ZW50LnVybCk7XG5cbiAgICAgIGlmIChjbGllbnQgJiYgaG9va3NCYXNlZEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICBpZiAoIWdldEFjdGl2ZVNwYW4oKSkge1xuICAgICAgICAgIHN0YXJ0QnJvd3NlclRyYWNpbmdOYXZpZ2F0aW9uU3BhbihjbGllbnQsIHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmlwcGVkVXJsLFxuICAgICAgICAgICAgb3JpZ2luOiAnYXV0by5uYXZpZ2F0aW9uLmFuZ3VsYXInLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAndXJsJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPVxuICAgICAgICAgIHN0YXJ0SW5hY3RpdmVTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IGAke25hdmlnYXRpb25FdmVudC51cmx9YCxcbiAgICAgICAgICAgIG9wOiBBTkdVTEFSX1JPVVRJTkdfT1AsXG4gICAgICAgICAgICBvcmlnaW46ICdhdXRvLnVpLmFuZ3VsYXInLFxuICAgICAgICAgICAgdGFnczoge1xuICAgICAgICAgICAgICAncm91dGluZy5pbnN0cnVtZW50YXRpb24nOiAnQHNlbnRyeS9hbmd1bGFyJyxcbiAgICAgICAgICAgICAgdXJsOiBzdHJpcHBlZFVybCxcbiAgICAgICAgICAgICAgLi4uKG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlciAmJiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvblRyaWdnZXI6IG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlcixcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIGxldCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG5cbiAgICAgIGlmICghYWN0aXZlVHJhbnNhY3Rpb24gJiYgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlKSB7XG4gICAgICAgIGFjdGl2ZVRyYW5zYWN0aW9uID0gc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IHN0cmlwcGVkVXJsLFxuICAgICAgICAgIG9wOiAnbmF2aWdhdGlvbicsXG4gICAgICAgICAgb3JpZ2luOiAnYXV0by5uYXZpZ2F0aW9uLmFuZ3VsYXInLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICd1cmwnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGAke25hdmlnYXRpb25FdmVudC51cmx9YCxcbiAgICAgICAgICBvcDogQU5HVUxBUl9ST1VUSU5HX09QLFxuICAgICAgICAgIG9yaWdpbjogJ2F1dG8udWkuYW5ndWxhcicsXG4gICAgICAgICAgdGFnczoge1xuICAgICAgICAgICAgJ3JvdXRpbmcuaW5zdHJ1bWVudGF0aW9uJzogJ0BzZW50cnkvYW5ndWxhcicsXG4gICAgICAgICAgICB1cmw6IHN0cmlwcGVkVXJsLFxuICAgICAgICAgICAgLi4uKG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlciAmJiB7XG4gICAgICAgICAgICAgIG5hdmlnYXRpb25UcmlnZ2VyOiBuYXZpZ2F0aW9uRXZlbnQubmF2aWdhdGlvblRyaWdnZXIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcblxuICAvLyBUaGUgUmVzb2x2ZUVuZCBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBBbmd1bGFyIHJvdXRlciBoYXMgcmVzb2x2ZWQgdGhlIFVSTCBhbmRcbiAgLy8gdGhlIHBhcmFtZXRlcjwtPnZhbHVlIG1hcHBpbmcuIEl0IGhvbGRzIHRoZSBuZXcgcmVzb2x2ZWQgcm91dGVyIHN0YXRlIHdpdGhcbiAgLy8gdGhlIG1hcHBpbmcgYW5kIHRoZSBuZXcgVVJMLlxuICAvLyBPbmx5IEFmdGVyIHRoaXMgZXZlbnQsIHRoZSByb3V0ZSBpcyBhY3RpdmF0ZWQsIG1lYW5pbmcgdGhhdCB0aGUgdHJhbnNhY3Rpb25cbiAgLy8gY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSBuYW1lIGJlZm9yZSBlLmcuIHRoZSByb3V0ZSdzIHJvb3RcbiAgLy8gY29tcG9uZW50IGlzIGluaXRpYWxpemVkLiBUaGlzIHNob3VsZCBiZSBlYXJseSBlbm91Z2ggYmVmb3JlIG91dGdvaW5nIHJlcXVlc3RzXG4gIC8vIGFyZSBtYWRlIGZyb20gdGhlIG5ldyByb3V0ZSwgd2l0aCB0aGUgZXhjZXB0aW9ucyBvZiByZXF1ZXN0cyBiZWluZyBtYWRlIGR1cmluZ1xuICAvLyBhIG5hdmlnYXRpb24uXG4gIHB1YmxpYyByZXNFbmQkOiBPYnNlcnZhYmxlPEV2ZW50PiA9IHRoaXMuX3JvdXRlci5ldmVudHMucGlwZShcbiAgICBmaWx0ZXIoKGV2ZW50KTogZXZlbnQgaXMgUmVzb2x2ZUVuZCA9PiBldmVudCBpbnN0YW5jZW9mIFJlc29sdmVFbmQpLFxuICAgIHRhcChldmVudCA9PiB7XG4gICAgICBjb25zdCByb3V0ZSA9IGdldFBhcmFtZXRlcml6ZWRSb3V0ZUZyb21TbmFwc2hvdChcbiAgICAgICAgKGV2ZW50LnN0YXRlIGFzIHVua25vd24gYXMgUm91dGVyU3RhdGUgJiB7IHJvb3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QgfSkucm9vdCxcbiAgICAgICk7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBnZXRBY3RpdmVUcmFuc2FjdGlvbigpO1xuICAgICAgLy8gVE9ETyAodjggLyAjNTQxNik6IHJldmlzaXQgdGhlIHNvdXJjZSBjb25kaXRpb24uIERvIHdlIHdhbnQgdG8gbWFrZSB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSB0aGUgZGVmYXVsdD9cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24gJiYgc3BhblRvSlNPTih0cmFuc2FjdGlvbikuZGF0YSkgfHwge307XG4gICAgICBpZiAodHJhbnNhY3Rpb24gJiYgYXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gPT09ICd1cmwnKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLnVwZGF0ZU5hbWUocm91dGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UsICdyb3V0ZScpO1xuICAgICAgICB0cmFuc2FjdGlvbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU4sIGBhdXRvLiR7c3BhblRvSlNPTih0cmFuc2FjdGlvbikub3B9LmFuZ3VsYXJgKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcblxuICBwdWJsaWMgbmF2RW5kJDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKFxuICAgICAgZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kIHx8IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkNhbmNlbCB8fCBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FcnJvcixcbiAgICApLFxuICAgIHRhcCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4hLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPSBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIHByaXZhdGUgX3JvdXRpbmdTcGFuOiBTcGFuIHwgbnVsbDtcblxuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfcm91dGVyOiBSb3V0ZXIpIHtcbiAgICB0aGlzLl9yb3V0aW5nU3BhbiA9IG51bGw7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLm5hdlN0YXJ0JC5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLnJlc0VuZCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZFbmQkLnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgd2hlbiB0aGUgcm9vdCB2aWV3IGlzIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBtdWx0aXBsZSB0aW1lcyxcbiAgICogc2luY2UgYHN1YnNjcmliZWAgY2FsbGJhY2tzIGNhcHR1cmUgYHRoaXNgIGFuZCBwcmV2ZW50IG1hbnkgcmVzb3VyY2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICovXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuXG5jb25zdCBVTktOT1dOX0NPTVBPTkVOVCA9ICd1bmtub3duJztcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t0cmFjZV0nIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3RyYWNlJykgcHVibGljIGNvbXBvbmVudE5hbWU/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfdHJhY2luZ1NwYW4/OiBTcGFuO1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBPbkluaXQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBVTktOT1dOX0NPTVBPTkVOVDtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIHRoaXMuX3RyYWNpbmdTcGFuID0gYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBgPCR7dGhpcy5jb21wb25lbnROYW1lfT5gLFxuICAgICAgICBvcDogQU5HVUxBUl9JTklUX09QLFxuICAgICAgICBvcmlnaW46ICdhdXRvLnVpLmFuZ3VsYXIudHJhY2VfZGlyZWN0aXZlJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBBZnRlclZpZXdJbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3RyYWNpbmdTcGFuKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3Bhbi5lbmQoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1vZHVsZSBzZXJ2ZXMgYXMgYSBzaW5nbGUgY29tcGlsYXRpb24gdW5pdCBmb3IgdGhlIGBUcmFjZURpcmVjdGl2ZWAgYW5kIGNhbiBiZSByZS11c2VkIGJ5IGFueSBvdGhlciBtb2R1bGUuXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1RyYWNlRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1RyYWNlRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhY2VNb2R1bGUge31cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGluaXRpYWxpemF0aW9uIGxpZmVjeWNsZSBvZiB0aGUgd2hvbGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gVHJhY2VDbGFzc0RlY29yYXRvcigpOiBDbGFzc0RlY29yYXRvciB7XG4gIGxldCB0cmFjaW5nU3BhbjogU3BhbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuICByZXR1cm4gdGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE9uSW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0YXJnZXQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxPbkluaXQ+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgY29uc3QgYWN0aXZlVHJhbnNhY3Rpb24gPSBnZXRBY3RpdmVUcmFuc2FjdGlvbigpO1xuICAgICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICB0cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgPCR7dGFyZ2V0Lm5hbWV9PmAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgICAgICBvcmlnaW46ICdhdXRvLnVpLmFuZ3VsYXIudHJhY2VfY2xhc3NfZGVjb3JhdG9yJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxPbkluaXQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Jbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbEFmdGVyVmlld0luaXQgPSB0YXJnZXQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxBZnRlclZpZXdJbml0PiB7XG4gICAgICBpZiAodHJhY2luZ1NwYW4pIHtcbiAgICAgICAgdHJhY2luZ1NwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxBZnRlclZpZXdJbml0KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEFmdGVyVmlld0luaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGEgc2luZ2xlIGxpZmVjeWNsZSBtZXRob2RzIG9mIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZU1ldGhvZERlY29yYXRvcigpOiBNZXRob2REZWNvcmF0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlLCBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIHJldHVybiAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbE1ldGhvZD4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zYWN0aW9uID0gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKTtcbiAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGA8JHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0+YCxcbiAgICAgICAgICBlbmRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICBvcDogYCR7QU5HVUxBUl9PUH0uJHtTdHJpbmcocHJvcGVydHlLZXkpfWAsXG4gICAgICAgICAgb3JpZ2luOiAnYXV0by51aS5hbmd1bGFyLnRyYWNlX21ldGhvZF9kZWNvcmF0b3InLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wOiBub3csXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsTWV0aG9kKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIHBhcmFtZXRlcml6ZWQgcm91dGUgZnJvbSBhIGdpdmVuIEFjdGl2YXRlZFJvdXRlU25hcHNob3QgYW5kIGNvbmNhdGVuYXRlcyB0aGUgc25hcHNob3Qnc1xuICogY2hpbGQgcm91dGUgd2l0aCBpdHMgcGFyZW50IHRvIHByb2R1Y2UgdGhlIGNvbXBsZXRlIHBhcmFtZXRlcml6ZWQgVVJMIG9mIHRoZSBhY3RpdmF0ZWQgcm91dGUuXG4gKiBUaGlzIGhhcHBlbnMgcmVjdXJzaXZlbHkgdW50aWwgdGhlIGxhc3QgY2hpbGQgKGkuZS4gdGhlIGVuZCBvZiB0aGUgVVJMKSBpcyByZWFjaGVkLlxuICpcbiAqIEBwYXJhbSByb3V0ZSB0aGUgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBvZiB3aGljaCBpdHMgcGF0aCBhbmQgaXRzIGNoaWxkJ3MgcGF0aCBpcyBjb25jYXRlbmF0ZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUgY29uY2F0ZW5hdGVkIHBhcmFtZXRlcml6ZWQgcm91dGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3Qocm91dGU/OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHwgbnVsbCk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGxldCBjdXJyZW50Um91dGUgPSByb3V0ZSAmJiByb3V0ZS5maXJzdENoaWxkO1xuICB3aGlsZSAoY3VycmVudFJvdXRlKSB7XG4gICAgY29uc3QgcGF0aCA9IGN1cnJlbnRSb3V0ZSAmJiBjdXJyZW50Um91dGUucm91dGVDb25maWcgJiYgY3VycmVudFJvdXRlLnJvdXRlQ29uZmlnLnBhdGg7XG4gICAgaWYgKHBhdGggPT09IG51bGwgfHwgcGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKHBhdGgpO1xuICAgIGN1cnJlbnRSb3V0ZSA9IGN1cnJlbnRSb3V0ZS5maXJzdENoaWxkO1xuICB9XG5cbiAgY29uc3QgZnVsbFBhdGggPSBwYXJ0cy5maWx0ZXIocGFydCA9PiBwYXJ0KS5qb2luKCcvJyk7XG4gIHJldHVybiBmdWxsUGF0aCA/IGAvJHtmdWxsUGF0aH0vYCA6ICcvJztcbn1cbiJdfQ==