import type { AfterViewInit, OnDestroy, OnInit } from '@angular/core';
import type { ActivatedRouteSnapshot, Event } from '@angular/router';
import { Router } from '@angular/router';
import { browserTracingIntegration as originalBrowserTracingIntegration } from '@sentry/browser';
import type { Integration, Transaction, TransactionContext } from '@sentry/types';
import type { Observable } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * Creates routing instrumentation for Angular Router.
 *
 * @deprecated Use `browserTracingIntegration()` instead, which includes Angular-specific instrumentation out of the box.
 */
export declare function routingInstrumentation(customStartTransaction: (context: TransactionContext) => Transaction | undefined, startTransactionOnPageLoad?: boolean, startTransactionOnLocationChange?: boolean): void;
/**
 * Creates routing instrumentation for Angular Router.
 *
 * @deprecated Use `browserTracingIntegration()` instead, which includes Angular-specific instrumentation out of the box.
 */
export declare const instrumentAngularRouting: typeof routingInstrumentation;
/**
 * A custom BrowserTracing integration for Angular.
 *
 * Use this integration in combination with `TraceService`
 */
export declare function browserTracingIntegration(options?: Parameters<typeof originalBrowserTracingIntegration>[0]): Integration;
/**
 * Grabs active transaction off scope.
 *
 * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
 */
export declare function getActiveTransaction(): Transaction | undefined;
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export declare class TraceService implements OnDestroy {
    private readonly _router;
    navStart$: Observable<Event>;
    resEnd$: Observable<Event>;
    navEnd$: Observable<Event>;
    private _routingSpan;
    private _subscription;
    constructor(_router: Router);
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TraceService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TraceService>;
}
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export declare class TraceDirective implements OnInit, AfterViewInit {
    componentName?: string;
    private _tracingSpan?;
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit(): void;
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TraceDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TraceDirective, "[trace]", never, { "componentName": "trace"; }, {}, never>;
}
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export declare class TraceModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<TraceModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<TraceModule, [typeof TraceDirective], never, [typeof TraceDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<TraceModule>;
}
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export declare function TraceClassDecorator(): ClassDecorator;
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export declare function TraceMethodDecorator(): MethodDecorator;
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concatenated
 *
 * @returns the concatenated parameterized route string
 */
export declare function getParameterizedRouteFromSnapshot(route?: ActivatedRouteSnapshot | null): string;
